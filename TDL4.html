<!doctype html>
<html lang="en">
<head>
	<title>TDL4 Specification</title>
<style>
* {
	font-family: Calibri, Arial, sans-serif;
}

body {
	max-width: 1000px;
	margin: auto;
}

p {
	margin: 1em auto;
}

table {
	border: #9cc2e5 1px solid;
	border-collapse: collapse;
	width: 100%;
	margin: 1em auto;
	min-width: 500px;
}

thead {
	border-bottom: #9cc2e5 3px solid;
}

td, th {
	padding-left: 2px;
	padding-right: 2px;
	border: #9cc2e5 1px solid;
	text-align: left;
	vertical-align: top;
}

h1, h2, h3, h4 {
	color: #3e7ebb;
	margin: 1em auto 0.3em;
}

div.hor-scroll {
	width : 100%;
	overflow-x: auto;
}

a {
	color: #3e7ebb;
}

a.toc {
	font-size: x-small;
	text-decoration: none;
	vertical-align: super;
}

img {
    flex: 1;
}
</style>
</head>

<body>
<h1>Transform Definition Language</h1>
<p>Version 4 release 4.4, January 2025</p>

<h2 id="TOC">Table of Contents</h2>
<p>
<a href="#General">General Description</a><br>
<a href="#DS">DS</a><br>
··· <a href="#DSPart">DS Partitioning</a><br>
··· <a href="#DSLife">DS Life Cycle</a><br>
··· ··· <a href="#Create">Create DS</a><br>
··· ··· <a href="#Transform">Transform DS</a><br>
··· ··· <a href="#Store">Store DS</a><br>
<a href="#Type">Type System</a><br>
··· <a href="#DSTypes">DS Types</a><br>
··· ··· <a href="#PlainText">PlainText</a><br>
··· ··· <a href="#Structured">Structured</a><br>
··· ··· <a href="#Passthru">Passthru</a><br>
··· ··· <a href="#Columnar">Columnar</a><br>
··· ··· <a href="#Spatial">Spatial DS Types</a><br>
··· ··· ··· <a href="#Point">Point</a><br>
··· ··· ··· <a href="#Track">Track</a><br>
··· ··· ··· <a href="#Polygon">Polygon</a><br>
··· <a href="#Attribute">Attribute, Variable, and Parameter Types</a><br>
··· ··· <a href="#Names">Names</a><br>
··· ··· <a href="#String">String Literals</a><br>
··· ··· <a href="#Numerics">Numerics </a><br>
··· ··· <a href="#Boolean">Boolean Type</a><br>
··· ··· <a href="#NULL">NULL</a><br>
··· ··· <a href="#Arrays">Arrays</a><br>
··· <a href="#Custom">Custom Object Types</a><br>
<a href="#Script">Script Structure</a><br>
··· <a href="#Top">Top-level Structure</a><br>
··· <a href="#Expressions">Expressions</a><br>
··· ··· <a href="#Automatic">Automatic Evaluation in Strings and Names</a><br>
··· ··· <a href="#ExpressionOperators">Expression Operators</a><br>
··· ··· <a href="#ExpressionFunctions">Expression Functions</a><br>
··· <a href="#Parameter">Parameter List Expressions</a><br>
<a href="#DataStorage">Data Storage Interface Statements</a><br>
··· <a href="#CREATEDS">CREATE DS Statement</a><br>
··· <a href="#COPY">COPY DS Statement</a><br>
<a href="#DataTransformation">Data Transformation Statements</a><br>
··· <a href="#TRANSFORMDS">TRANSFORM DS Statement</a><br>
<a href="#DataManipulation">Data Manipulation Statements</a><br>
··· <a href="#SELECT">SELECT Statement</a><br>
··· <a href="#CALL">CALL Statement</a><br>
··· <a href="#ANALYZE">ANALYZE Statement</a><br>
···	··· <a href="#PARTITION">Per-partition</a><br>
<a href="#Control">Control Flow Statements</a><br>
··· <a href="#LET">LET Statement</a><br>
··· <a href="#IF">IF Statement</a><br>
··· <a href="#LOOP">LOOP Statement</a><br>
··· <a href="#RAISE">RAISE Statement</a><br>
··· <a href="#CREATEPROC">CREATE PROCEDURE Statement</a><br>
··· <a href="#DROPPROC">DROP PROCEDURE Statement</a><br>
··· <a href="#CREATEFUNC">CREATE FUNCTION Statement</a><br>
··· <a href="#DROPFUNC">DROP FUNCTION Statement</a><br>
<a href="#Settings">Settings Statements</a><br>
··· <a href="#OPTIONS">OPTIONS Statement</a><br>
</p>

<h2 id="General">General Description <a class="toc" href="#TOC">↑</a></h2>
<p>Transform Definition Language version 4 (TDL4) is a domain-specific language designed to describe ETL processes to perform with Data Cooker ETL tool. The strongest emphasis is on the Transformation phase.</p>
<p>Syntax of TDL4 is inspired by and based on SQL, but has substantial semantic differences due to Data Cooker's differences from traditional RDBMS. Instead of SQL tables that consist of column-based rows, Data Cooker operates with strongly typed collections of Record Objects called 'DS' (for Data Sets / Data Streams). Also, Transformation phase of ETL does not imply analytic workloads or complex data manipulation that traditional SQL facilities usually provide.</p>
<p>As an SQL dialect, TDL4 is mainly declarative but also has substantial means of flow control, and even procedural elements.</p>
<p>Another difference from SQL engines is that Data Cooker doesn't require global data catalog nor information schema. A rudimentary partial schema is defined ad hoc by language statements only if required by current context. It doesn't imply control over data types, nor integrity, neither consistency, neither enforces data constraints.</p>
<p>TDL4 allows high level manipulation over DSs as a whole, and intentionally omits features like aggregation, window functions, and anything that reduces several records of given DS to a single value. Only record-level expression evaluations for record attributes are provided by SELECT and similar statements. Those Expression Operators and Functions are implemented as Java classes and thus are extensible.</p>
<p>At the same time, Data Cooker's language interpreter also does provide built-in support for pluggable 'Operations' and 'Transforms' to allow more complex manipulations with DS written in Java. By implementing an Operation interface, developers are allowed to seamlessly integrate custom logic into ETL processes, including generation of new DS and changing data inside of them as they like. With Transforms, it is possible to change type of DS Record Objects.</p>
<p>Another level of extensibility is provided by 'Storage Adapters' layer of plug-ins that covers Extract and Load phases of ETL processing.</p>
<p>TDL4 does have specific type system, customized for DS that contain not only relatively flat Records, but also complex Spatial Objects with embedded geometry data, because Data Cooker's heritage begins from a geo-informatic processing toolchain.</p>

<h2 id="DS">DS <a class="toc" href="#TOC">↑</a></h2>
<p>In terms of Data Cooker, a DS (short for Data Stream and/or Data Set) is a basic entity of every ETL process.</p>
<p>DS is a typed collection of Objects, that may have or not complex type-dependent internal structure, and/or a set of simple Attributes, accessible from the ETL process by Names. Each Object together with a Key (which may be opaque value or even another Object) form an elementary unit of processing, the Record.</p>

<h3 id="DSPart">DS Partitioning <a class="toc" href="#TOC">↑</a></h3>
<p>DSs are partitioned — split into chunks called Partitions, to balance the load of Spark executors because they process a single Partition at a time. Number of Partitions in most cases must be set manually, but if not, it'll be defined by Input Adapter using intrinsic properties of data source and execution environment.</p>
<p>Records are assigned to Partitions by hash codes of their Keys. Correct definition of Keys is crucial to avoid 'data skew' (a situation when a small number of Partitions contain most of the records while all others are empty).</p>
<p>In most cases, Data Cooker allows consumption of a DS either as a whole or as a subset of Partitions (from single part to all). If that subset is specified, new DS is transparently created from the parent one on the fly. For efficient processing on Partition basis, Keys must be stable and have a uniform distribution across entire DS.</p>

<h3 id="DSLife">DS Life Cycle <a class="toc" href="#TOC">↑</a></h3>
<p>According to definition of ETL, DSs can be created (once), transformed (many times), and stored (several times).</p>
<p>In Data Cooker, a DS can be created by several means from the external source of data or from other existing DSs.</p>

<h4 id="Create">Create DS <a class="toc" href="#TOC">↑</a></h4>
<p><b>Create method #1.</b> Input Adapters extract data from the data source, which could be some object or file-based storage, a traditional database, or something else. Each Input Adapter supports creation of a single type of DS, but may support different data sources.</p>
<p>Initial Key of newly created Record is set by Input Adapter, then DS is partitioned using those initial keys. Rules for a concrete Input Adapter are documented by its developer.</p>
<p><b>Method #2.</b> A DS can be derived from one or many existing by performing an SQL-like SELECT query. Type and partitioning of a derived DS is inherited from parent DSs. See SELECT section of this manual for details.</p>
<p><b>Method #3</b> to create a DS is to call an Operation that generates new DS from existing ones using its own rules. There are some common patterns described below in the CALL section, but exact rules are documented by the developer of the Operation.</p>

<h4 id="Transform">Transform DS <a class="toc" href="#TOC">↑</a></h4>
<p>After DS is created, it may be <b>transformed</b> by Transforms, changing its Record type and/or Key, as well as number of Partitions. Number of objects can also change if one source object corresponds to many resulting ones and vice versa. There can be performed as many consecutive Transforms on a given DS as needed. As Transforms are pluggable, transformation rules are documented by developer.</p>
<p>If Record Keys are changed by applying a Transform, affected Records may be assigned to other Partitions, if needed.</p>

<h4 id="Store">Store DS <a class="toc" href="#TOC">↑</a></h4>
<p>Final step of DS's life cycle is <b>storage</b> to some external data store, performed by Output Adapter. An Output Adapter may store different types of DSs into different formats. Rules, as usual, are documented by developer.</p>

<h2 id="Type">Type System <a class="toc" href="#TOC">↑</a></h2>
<p>Differing from SQL, TDL4 data types are defined first on the level of DS as a whole for each Record Object, and then by level of Record Attributes and language constructs.</p>

<h3 id="DSTypes">DS Types <a class="toc" href="#TOC">↑</a></h3>
<p>Record Objects may have or not an internal structure, and if Record Object type does allow Attributes, each Attribute type is dynamically coalesced to match the context of expression that references it, if possible.</p>
<p>Supported types are:</p>
<ul>
	<li>General purpose:
<ul>
	<li><b>PlainText</b> — unstructured data. Each object is just array of bytes, treated in most cases as plain text in system encoding (most likely, UTF8). Does not have Attributes.</li>
	<li><b>Structured</b> data records map arbitrary property names to their respective values, or an array of values, where any property may be a map or array itself (even the topmost object). Treat this data type as generic JSON data. Record Attributes expose all properties for reading, but only top-level ones for writing.</li>
	<li><b>Passthru</b> is a special type that marks DS's type as 'unchanged during the transformation'.</li>
</ul>
	</li>
	<li>Column-based data:
		<ul>
<li><b>Columnar</b> — each object is a flat record that consists from a fixed number of directly named 'columns', fully accessible via Attributes.</li>
		</ul>
	</li>
	<li>Spatial / Geometric data:
<ul>
	<li><b>Point</b> — each object represents a Point on a map with optional radius, and a set of arbitrarily named properties accessible via Attributes.</li>
	<li><b>Track</b> — each object is a collection of regular Points (with 3rd-level Attributes), organized into Segments. Track and Segments also may have their own arbitrarily named properties (accessible via top-level and 2nd-level Attributes).</li>
	<li><b>Polygon</b> — each object represents a Polygon on a map, but without direct access to its vertices. Polygon may have holes. It may have a set of arbitrarily named properties too accessible via Attributes.</li>
</ul>
	</li>
</ul>

<h4 id="PlainText">PlainText <a class="toc" href="#TOC">↑</a></h4>
<p>After loading a DS from unstructured text source, each line is represented as text in the system encoding (usually, UTF8), or byte array. Before performing meaningful transformations on the data contained in that set, it should be converted to another, structured type.</p>
<p>Vice versa, before saving structured DSs to text-based file formats, it should be converted to PlainText.</p>

<h4 id="Structured">Structured <a class="toc" href="#TOC">↑</a></h4>
<p>Each object of a Structured DS is backed by a JSON representation, so it can be as arbitrary as it fits within JSON limitations. Namely, String, Numeric, Boolean, an NULL properties are supported, as well as homogenous arrays (with every member of same type). Top level object may be an array itself.</p>
<p>Each top-level property is an Attribute itself (read-write), and nested properties' Attribute names are compound (read only). They may include array index or range part too.</p>

<h4 id="Passthru">Passthru <a class="toc" href="#TOC">↑</a></h4>
<p>This type is not a data type per se, but just a marker reported from API calls to plugin Transforms that means it doesn't change data type in the set.</p>

<h4 id="Columnar">Columnar <a class="toc" href="#TOC">↑</a></h4>
<p>Each object of DS of that type is a record consisting of uniquely named columns, enumerated in the specified order. After enumerated, they can be accessed via Attributes of same name.</p>
<p>Data in the column doesn't have an explicit type, nor it has any metadata except name. Columns, omitted from the record, have automatically assigned NULL values.</p>

<h4 id="Spatial">Spatial DS Types <a class="toc" href="#TOC">↑</a></h4>
<p>Because Data Cooker inherited preceding project legacy which was a geo-informatics project, TDL4 natively supports geometry-specific Spatial data types implemented as extensions to JTS Topology Suite and GeoJSON.</p>

<h4 id="Point">Point <a class="toc" href="#TOC">↑</a></h4>
<p>Objects of that type are abstractions of Points a map with an optional set of arbitrary Attributes.</p>
<p>Being an extension of JTS Point, each object has mandatory internal attributes of geographic 'latitude' and 'longitude'.</p>

<h4 id="Track">Track <a class="toc" href="#TOC">↑</a></h4>
<p>Object of a Track is an abstraction of a route traveled by some physical object over the real-world map. It consists of Points, grouped together by an appointed 'tracking' Attribute, and sorted by another 'timestamp' Attribute, optionally cut into segments by 'segmentation' Attribute. If segmentation Attribute is not defined, there still be a single segment that includes all points of a track.</p>
<p>Each level of nested objects (Track, Segments, Points) may have an arbitrary number of other named Attributes.</p>

<h4 id="Polygon">Polygon <a class="toc" href="#TOC">↑</a></h4>
<p>A region on a map, defined as a collection of a single external border outline and any number of internal cut-out outlines, with an arbitrary number of other named attributes.</p>
<p>There is no direct access to vertices of Polygon outlines, but there is an automatically computed Centroid Point, with radius set to its most distant border vertex.</p>

<h3 id="Attribute">Attribute, Variable, and Parameter Types <a class="toc" href="#TOC">↑</a></h3>
<p>Outside DSs, there are also script-level Variables, and Expression- / Pluggable Entity-level Parameters, that may have their own types, more or less similar to SQL: Names, String, Numeric, Boolean, NULL, and Arrays.</p>
<p>Simple literals are defined like this:</p>
<div class="hor-scroll"><img src="./spec/literal.svg" alt="literal"></div>

<h4 id="Names">Names <a class="toc" href="#TOC">↑</a></h4>
<p>Names are used to define and identify any entities that have to be referred to in the script, i.e. DSs, Attributes, Parameters, Variables, and so on.</p>
<p>Canonical representation of a Name is a string of Latin alphabet letters, numbers (any position except first), and underscores, or a string of any valid Unicode characters enclosed in double quotes. If name should contain a character of double quote itself, it must be doubled. If name clashes with a TDL4 keyword, it must be quoted.</p>
<p><b>ALL Names are case-sensitive.</b></p>
<p>Quoted representation of names provides automatic expression evaluation (see later in a dedicated paragraph).</p>
<p>Names could be joined by a dot to create compound names, used in SELECTs with JOINs.</p>
<p>Names of Variables are always explicitly identified by preceding 'dollar sign' <b>$</b> sigil. Names of Parameters are likewise preceded by 'commercial at' <b>@</b> sigil.</p>

<h4 id="String">String Literals <a class="toc" href="#TOC">↑</a></h4>
<p>String literals are fragments of arbitrary Unicode text enclosed in apostrophes. If a String should contain an apostrophe, it must be doubled.</p>
<p>String literals are always automatically evaluated (see later).</p>

<h4 id="Numerics">Numerics <a class="toc" href="#TOC">↑</a></h4>
<p>There are different representations of immediate Numeric values allowed:</p>
<ul>
	<li>Equivalent of Java Double: <b>[s]99[.99][E[s]99][D]</b> or <b>[s].99[E[s]99][D]</b>.</li>
	<li>Equivalent of Java Long: <b>[s]99[L]</b>.</li>
	<li>'Unsigned Long' for bit-masking operators: <b>0xHH</b>.</li>
	<li>Equivalent of Java Integer: <b>[s]99</b>.</li>
</ul>
<p><b>99</b> here means a sequence of decimal numbers, <b>HH</b> for hexadecimal numbers, <b>s</b> is sign sigil (+ or -). Parts in square braces are optional, symbols <b>E</b>, <b>L</b>, <b>.</b> (dot) and <b>0x</b> are used as is.</p>

<h4 id="Boolean">Boolean Type <a class="toc" href="#TOC">↑</a></h4>
<p>Literal <b>TRUE</b> is used for Boolean truth and literal <b>FALSE</b> for Boolean falseness.</p>

<h4 id="NULL">NULL <a class="toc" href="#TOC">↑</a></h4>
<p>Like in SQL, <b>NULL</b> is used for non-value.</p>
<p>Most of the expressions that include NULL evaluate to NULL, except ones that use truth table similar to OR operator, and some other specific cases (sse in the dedicated topic). As in SQL, no NULL is equal to another NULL.</p>
<p>A Variable or parameter that is not defined in the current context evaluates to NULL as well.</p>

<h4 id="Arrays">Arrays <a class="toc" href="#TOC">↑</a></h4>
<p>TDL supports loosely-typed Arrays. Arrays may be used in LOOP control structures, IN operator, to pass collections to Pluggable Entities as Parameters, and in other contexts.</p>
<p>Virtually anything can be collected into Arrays by Pluggable Entities such as Functions, but literal array constructors supports only simple literals. Constructor syntax is just a list of values separated by comma, enclosed in square brackets (for example, <b>... WHERE "month" IN ['Nov', 'Dec', 11, 12]</b>). Optional keyword ARRAY may be used before the opening bracket (for example, <b>LOOP $i ARRAY['a', 'b', 'c'] BEGIN ...</b>). Arrays may be empty (just <b>[]</b>).</p>
<p>Arrays of Names are supported <b>only</b> in context of Pluggable Entity Parameters (<b>CALL something(@affect_columns=["first","third","fourth"]) ...</b>), and throw an error otherwise. Names cannot be mixed with other literals.</p>
<p>For Arrays that consist of Numeric values over some continuous range, there is a special constructor syntax as well.</p>
<div class="hor-scroll"><img src="./spec/array.svg" alt="array"></div>
<p>Ranges may be ascending or descending and always include both boundaries. For example, <b>RANGE[1,-1]</b> is equivalent of <b>ARRAY[1,0,-1]</b>. If both boundaries of Range have type of Integer, then all values in the Range will be Integer. If any is Long, then all will be Long (and Doubles are converted to Long).</p>

<h3 id="Custom">Custom Object Types <a class="toc" href="#TOC">↑</a></h3>
<p>Some Operations and even Expression Functions define their own specific subtypes of data types that they interpret with their own set of rules. Those types are referred to as 'Something-like Objects'.</p>
<p>For example, standard date/time manipulation functions operate with DateTime-like Objects, which are represented by Long Epoch seconds or milliseconds, or String formatted as a ISO8601-alike timestamp.</p>
<p>Another example, some spatial Operations may extend existing Point Record type with custom 'radius' attribute measured in meters, that makes them POI-like Objects (for Points of Interest).</p>

<h2 id="Script">Script Structure <a class="toc" href="#TOC">↑</a></h2>

<h3 id="Top">Top-level Structure <a class="toc" href="#TOC">↑</a></h3>
<p>TDL4 script is a sequence of any number of statements, each ending with a mandatory semicolon.</p>
<div class="hor-scroll"><img src="./spec/script.svg" alt="script"></div>
<p>Each simple language statement is executed in current execution context, starting with top-level, while compound statements run nested statements in their own nested context. List of language statements is as of follows:</p>
<div class="hor-scroll"><img src="./spec/statement.svg" alt="statement"></div>
<p>Whitespace and tabulation characters are ignored and may be freely used for means of readability. Script may be empty, there is no error.</p>

<h3 id="Expressions">Expressions <a class="toc" href="#TOC">↑</a></h3>
<p>Expressions can be evaluated in two distinct contexts. First is 'Loose Expression' that can refer to any script-level entities. Another one is 'Record-level Expression' which can also refer to Record Attributes by their Names.</p>
<div class="hor-scroll"><img src="./spec/expression.svg" alt="expression"></div>
<p>Record-level evaluation rules take place only where it makes sense (SELECT, WHERE, KEY clauses contexts).</p>

<h4 id="Automatic">Automatic Evaluation in Strings and Names <a class="toc" href="#TOC">↑</a></h4>
<p>There is automatic expression evaluation performed inside quoted Names and String literals. Any text between curly braces <b>{</b> and <b>}</b> inside quoted Name or String is evaluated as an expression, and result is substituted as a substring in-place.</p>
<p>To turn off automatic evaluation, braces should be prepended by a backslash <b>\</b>.</p>
<p>Please note that quoted entities evaluation happen in the context of parse time of language Operator, not the call time. As such, quoted entities won't re-evaluate themselves in SELECT clauses on per-Record basis. Use Expression Functions there instead.</p>

<h4 id="ExpressionOperators">Expression Operators <a class="toc" href="#TOC">↑</a></h4>
<p>There are three SQL-specific 'peculiar' Operators implemented right by TDL4 interpreter: IN, IS, and BETWEEN.</p>
<div class="hor-scroll"><table>
	<thead>
	<tr><th>Symbol<br>(Variants)</th><th>Priority</th><th>Associativity</th><th># of Operands</th><th>Description</th></tr>
	</thead>
	<tbody>
	<tr><td>Operand [NOT] IN ARRAY[]<br>Operand [NOT] IN $array_var<br>Operand [NOT] IN array_attr</td><td>35</td><td>Right</td><td>2</td><td>TRUE if left operand is present in the right, cast to Array, FALSE otherwise. Vice versa for NOT variant</td></tr>
	<tr><td>Operand IS [NOT] NULL</td><td>35</td><td>Right</td><td>1</td><td>TRUE if left operand is NULL, FALSE otherwise. Vice versa for NOT variant</td></tr>
	<tr><td><nobr>Operand [NOT] BETWEEN Min AND Max</nobr></td><td>35</td><td>Right</td><td>3</td><td>TRUE if left operand is inclusively between Min and Max operands, cast to Numerics, FALSE otherwise. For NOT variant, TRUE if it is outside the range, excluding boundaries</td></tr>
	</tbody>
</table></div>
<p>All other Operators that can be used in Expressions are modeled after Java operators (down to symbolic representation), and/or implemented elsewhere in the classpath (and thus have a keyword-like name), and their list is extensible / dependent of distribution.</p>
<p>If an Operator requires operands of concrete data type, they will be directly cast or stringified-then-parsed to that type. If cast or parsing is impossible, Data Cooker throws an error and halts script execution.</p>
<p>Operators with higher priority are evaluated before lower priority operators. In case of same priority, evaluation is left to right except if Operator is right-associative or unary. For subexpression grouping and changing of evaluation order, parentheses can be used.</p>
<p>Most Operators result in NULL if any of their operands are NULL, but some do handle NULLs in a specific way.</p>
<p>For the exact list of available Operators, their Priority, Associativity, and NULL handling, look into automatically generated distro docs.</p>

<h4 id="ExpressionFunctions">Expression Functions <a class="toc" href="#TOC">↑</a></h4>
<p>A function call has the following syntax:</p>
<div class="hor-scroll"><img src="./spec/func_call.svg" alt="func_call"></div>
<p>Functions may have any number of strictly positional Arguments (1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, and so on). Some have a fixed list of strongly typed Arguments, some accept any number of Arguments that are automatically cast to a single type. There are also functions that have no arguments and therefore return some predefined value, or even refer to Object Record as a whole and access its internal data, such as Spatial Object's geometry.</p>
<p>In any case, Arguments are evaluated from left to right.</p>
<p>Expressions in parentheses are considered as a special case of function call of an identity function (that returns is only argument unchanged), to allow parentheses to change evaluation order of compound expressions.</p>
<p>Record-level Functions can be called only from Record-level Attribute Expressions, and are invalid in the Loose Expression context. Calling them outside SELECT, WHERE, or KEY clauses will cause an error.</p>
<p>Expression Functions are provided in two ways. First, same as Operators, by Java implementations from the classpath. For the complete list of Pluggable Functions, their return and Argument types refer to your distro docs. Second, Language-level Functions may be defined on the script immediately, or in the library script. This method is discussed further in this document.</p>

<h3 id="Parameter">Parameter List Expressions <a class="toc" href="#TOC">↑</a></h3>
<p>Parameter lists are expressions composed of parameters (at least one), separated by commas.</p>
<div class="hor-scroll"><img src="./spec/params_expr.svg" alt="params_expr"></div>
<p>Each parameter is a name to value (which may be expression or array literal) pair.</p>
<div class="hor-scroll"><img src="./spec/param.svg" alt="param"></div>
<p>Parameter lists are usually passed to named function-like expressions (TRANSFORM, CALL, and so on). In that case parameter lists are bound to Record-level context and can refer to DS Record Attributes.</p>

<h2 id="DataStorage">Data Storage Interface Statements <a class="toc" href="#TOC">↑</a></h2>

<h3 id="CREATEDS">CREATE DS Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Creates a new DS from data source. Its name must be new and unique.</p>
<div class="hor-scroll"><img src="./spec/create_stmt.svg" alt="create_stmt"></div>
<p>Functional expression includes Input Adapter name and its parameter list. List of available Input Adapters depends on the distribution.</p>
<p>FROM expression evaluates to a path String pointing to data source. Each Input Adapter has its own syntax of path, which could be a URI, a query, or something more specific.</p>
<p>Number of partitions is set by PARTITION clause. Its expression evaluates to Java Integer number of partitions. If not set, single partition DS is created.</p>
<p>Initial object keying, and thus, initial partitioning can be changed by the BY algorithm clause. Default algorithm is HASHCODE, which sets initial Record Key to Java hashcode of the Record Object itself, so identical objects will be placed into same partitions. SOURCE derives Keys from source file name (or storage-dependent analog, it if's not file-based), so all Records from same source file will go to same partition. RANDOM sets keys to random values, effectively evenly shuffling records between partitions.</p>
<p>In any case, initial key is a Java Integer numeric.</p>

<h3 id="COPY">COPY DS Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Saves existing DS to storage.</p>
<div class="hor-scroll"><img src="./spec/copy_stmt.svg" alt="copy_stmt"></div>
<p>Likewise, INTO expression evaluates to a path String (usually, a URI) pointing to a data storage location, with a syntax specific to each Output Adapter. List of available Output Adapters depends on the distribution.</p>
<p>If a star is used after DS name, it is treated as a prefix, and all matching DSs will be copied to storage (usually, into subdirectories under specified INTO path for file-based storages). Each partition would usually go to a separate file.</p>
<p>This Statement supports per-Partition processing.</p>
<div class="hor-scroll"><img src="./spec/ds_parts.svg" alt="ds_parts"></div>
<p>If needed, DS name could have additional PARTITION specifier, which has an expression that evaluates to a single Integer Partition number, or to Integer ARRAY or RANGE of Partitions to address. If star-syntax is used, all prefixed DSs must have addressed partitions.</p>

<h2 id="DataTransformation">Data Transformation Statements <a class="toc" href="#TOC">↑</a></h2>

<h3 id="TRANSFORMDS">TRANSFORM DS Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Invokes a Transform to convert a DS from one type to another. Instead of keyword TRANSFORM, ALTER may be used.</p>
<div class="hor-scroll"><img src="spec/transform_stmt.svg" alt="transform_stmt"></div>
<p>Is a star is used after DS name, it is treated as a prefix, and all matching DSs will be transformed with same parameters.</p>
<p>Functional expression includes name of Transform and list of its parameters. As transforms are pluggable, exact list depends on a distribution, and thus they're documented separately.</p>
<p>An item of column definitions of a certain type has the following structure:</p>
<div class="hor-scroll"><img src="./spec/columns_item.svg" alt="columns_item"></div>
<p>In case of the COLUMNS list with ($variable) syntax, referenced variable must be of type of Array of Names.</p>
<p>'Type of columns' in this context depend on the DS type.</p>
<div class="hor-scroll"><table>
	<thead><tr><th>DS Type</th><th>Type of Attributes</th><th>Record Object Level</th></tr></thead>
	<tbody>
	<tr><td>PlainText</td><td>VALUE</td><td>There are no Attributes</td></tr>
	<tr><td>Columnar</td><td>VALUE</td><td>Column names of the record object</td></tr>
	<tr><td>Structured</td><td>VALUE</td><td>Property names of the record object</td></tr>
	<tr><td>Point</td><td>POINT or POI or VALUE</td><td>Attributes of Point object</td></tr>
	<tr><td rowspan="3">Track</td><td>TRACK or SEGMENTEDTRACK or VALUE</td><td>Attributes of Track (level 1 object)</td></tr>
	<tr><td>SEGMENT or TRACKSEGMENT</td><td>Attributes of Segments (level 2 objects)</td></tr>
	<tr><td>POINT or POI</td><td>Attributes of Points (level 3 objects)</td></tr>
	<tr><td>Polygon</td><td>POLYGON or VALUE</td><td>Attributes of Polygon object</td></tr>
	</tbody>
</table></div>
<p>Key item is a Record-level expression, referring to existing DS attributes:</p>
<div class="hor-scroll"><img src="spec/key_item.svg" alt="key_item"></div>
<p>If KEY expression is specified, each DS Record will be assigned with newly calculated Key.</p>
<p>Key evaluation incidence depends on the Transform. Most evaluate keys before the record is transformed, but there are some that do it after (for example, if source Record is PlainText no Attributes are available before transformation). See Transforms documentation to find out.</p>
<p>If there is a PARTITION clause, Records will then be redistributed between new partitions according to their new Keys (according to number of PARTITION expression evaluated to Integer). Be aware that raw result of KEY expression is used to set Record Key, so if it evaluates to a constant, all records will go into one partition. If there is no PARTITION, only Keys will be changed, but no redistribution is performed.</p>
<p>To keep existing number of partitions, just omit PARTITION expression, leaving only a keyword.</p>
<p>If statement includes PARTITION clause without KEY, DS will be repartitioned to a desired number of partitions after transforming, but using HASHCODE partitioning over existing Keys.</p>

<h2 id="DataManipulation">Data Manipulation Statements <a class="toc" href="#TOC">↑</a></h2>

<h3 id="SELECT">SELECT Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Perform an SQL-like query to one or more existing DSs and create a new, resulting DS. Its name, specified in INTO clause, must be new and unique.</p>
<div class="hor-scroll"><img src="spec/select_stmt.svg" alt="select_stmt"></div>
<p>Query part is a star (with meaning 'select all available attributes') or a list of 'what to select' expressions. Resulting DS attributes are named according to aliases (if specified) or stringified expression (expression text with all whitespace removed):</p>
<div class="hor-scroll"><img src="./spec/what_expr.svg" alt="what_expr"></div>
<p>If same alias is set for several expressions, rightmost will rewrite result of all preceding (there can't be many attributes with same name in DS object). Aliases are set per column type (same as in TRANSFORM).</p>
<p>SELECT expressions are bound to Record-level context for all DS participating in the SELECT.</p>
<p>For Structured SELECTs, compound property names must be used to access nested properties using dot notation ("top.inner.innermost"), and zero-based array indices or ranges to access array members. For example, "prop.inner[0]" for 1st menber of "prop.inner" array, or "[2].prop" for 3rd topmost array member's property "prop". Ranges may be specified only for innermost properties (no dots allowed afterward): "prop[*]" or "prop[]" for entire array "prop", "prop[1:]" from 2nd member onwards, "prop[:5]" up to 6th, "prop[2:4]" from 3rd to 5th. Range boundaries may be negative which means 'Nth member from array end'. If right range goes past array size, result will be NULL padded. If boundaries overlap or both go beyond beginning, empty array will be returned.</p>
<p>In case of straight JOINs, fully-qualified compound names for attributes from different DSs must be used in the same dot notation.</p>
<p>Source scope is specified in the FROM clause:</p>
<div class="hor-scroll"><img src="spec/from_scope.svg" alt="from_scope"></div>
<p>Queries can be performed to a single or many (with UNION) DS of any type, or multiple JOINed KeyValue DSs.</p>
<p>Query to a single DS is equivalent of iteration over all its data and simple evaluation of what-to-select items, then applying constraints.</p>
<p>In the case of a single DS with * query and no other constraints, a 'fast shallow copy' of DS is performed (just a new name to same underlying data is assigned).</p>
<p>UNIONs could unite either all listed DSs, or if a star syntax is used, all DSs with names that have specified prefix. There are several types of UNION operation available:</p>
<div class="hor-scroll"><img src="./spec/union_op.svg" alt="union_op"></div>
<div class="hor-scroll"><table>
	<thead><tr><th>UNION Operation</th><th>Result</th></tr></thead>
	<tbody>
		<tr><td>By default, CONCAT or CAT</td><td>Records of all DSs are queried, in order of occurrence</td></tr>
		<tr><td>XOR</td><td>Only records that are unique to their source DSs are queried, other are discarded</td></tr>
		<tr><td>AND</td><td>Only records that are occurred in all participating DSs are queries, other are discarded</td></tr>
	</tbody>
</table></div>
<p>UNION can be applied to DSs of same type only. Also, for UNION to be successful, all top-level objects of participating DSs must have top-level attributes of same names.</p>
<p>JOINs can be used to form new objects from participating DSs Objects that have same Record keys. There are following JOIN operations available:</p>
<div class="hor-scroll"><img src="spec/join_op.svg" alt="join_op"></div>
<p>Resulting record objects of straight JOINs have internal data from the first meaningful Object occurred in the DS iteration order, while Attributes are read from all JOINed sets, using compound name with dot notation (1st part is set name, then attribute name). For subtracting JOINs, however, only one set is the source of resulting objects, thus only that object Attributes are available, using simple name.</p>
<div class="hor-scroll"><table>
	<thead><tr><th>JOIN Operation</th><th>Type</th><th>Result Evaluation Rules</th><th>Result Type</th></tr></thead>
	<tbody>
	<tr><td>By default, INNER</td><td>Straight</td><td>Records that have matching keys in all participating DSs are queried, other discarded. Records always have all Attributes from all participating sets</td><td>1st set</td></tr>
		<tr><td>LEFT</td><td>Straight</td><td>DSs are iterated from left to right. Result records always have columns form 1st DS, and from subsequent DSs records with same keys. If there is no record with matching key, NULLs will be used for its attributes</td><td>1st set</td></tr>
		<tr><td>LEFT ANTI</td><td>Subtracting</td><td>DSs are iterated from left to right. Records from 1st DS that have no matching keys in all subsequent DSs will be queried, other discarded</td><td>1st set</td></tr>
		<tr><td>RIGHT</td><td>Straight</td><td>DSs are iterated from right to left. Result records always have columns form last DS, and from preceding DSs records with same keys. If there is no record with matching key, NULLs will be used for its attributes</td><td>Last set</td></tr>
		<tr><td>RIGHT ANTI</td><td>Subtracting</td><td>DSs are iterated from right to left. Records from last DS that have no matching keys in all subsequent DSs will be queried, other discarded</td><td>Last set</td></tr>
		<tr><td>OUTER</td><td>Straight</td><td>DSs are iterated from left to right. Result records always have columns form all DSs records with same keys. If there is no record with matching key, NULLs will be used for its attributes</td><td>1st set</td></tr>
	</tbody>
</table></div>
<p>Note that any referenced DS in the FROM clause may have it own PARTITION specifier, if needed. In case of star-syntax all prefixed DSs must have referenced parts.</p>
<p>There are 3 types constraints available to narrow down the query results: WHERE, DISTINCT, and LIMIT clauses.</p>
<p>WHERE constraint is a single Boolean expression (applicable only to one level of object selected by type alias, if there are many), evaluated before 'what-to-select' expressions and all other constraints for each record. If result is TRUE, record is queried, otherwise discarded.</p>
<div class="hor-scroll"><img src="./spec/where_expr.svg" alt="where_expr"></div>
<p>DISTINCT, if specified, is applied after resulting query is evaluated. Of all records that have been evaluated to exactly same key and object, there will be only one left, and any repeats discarded.</p>
<p>LIMIT is applied at the very last, and comes in two flavors, by count and by percentage. Count can be specified in any valid Numeric format, and the resulting DS will have at most the specified number of records, randomly selected. If set by percentage, it must fall into a range from 0 (exclusive) to 100 (inclusive), and result will have randomly trimmed down to set percentage of records. If invalid percentage is specified, that will lead to an error.</p>
<div class="hor-scroll"><img src="./spec/limit_expr.svg" alt="limit_expr"></div>
<p>To summarize, the order of SELECT evaluation is as of follows:</p>
<ol>
	<li>Check of existence of INTO DS name</li>
	<li>Iteration, JOIN, or UNION over source scope of DSs</li>
	<li>WHERE constraint expression</li>
	<li>'What-to-select' expressions, from left to right</li>
	<li>DISTINCT constraint</li>
	<li>LIMIT constraint</li>
</ol>

<h3 id="CALL">CALL Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Serves to call pluggable Operations, akin to SQL stored procedures (but with a substantial semantic difference), or TDL Procedures (see further below).</p>
<div class="hor-scroll"><img src="./spec/call_stmt.svg" alt="call_stmt"></div>
<p>Functional expression includes name of an Operation or Procedure and its parameters. Full list of available Operations depends on distribution, thus them and their parameters are documented separately. TDL Procedures are ephemeral and exist only in the current execution context.</p>
<div class="hor-scroll"><img src="./spec/func_expr.svg" alt="func_expr"></div>
<p>Operations always create new DSs from existing and require INPUT FROM and OUTPUT INTO DS references (in either order).</p>
<div class="hor-scroll"><img src="./spec/operation_io.svg" alt="operation_io"></div>
<p>Like SELECT, there is source scope of DSs, set by INPUT clause. There are two flavors of source scope, depending on Operation.</p>
<p>Positional INPUT is either a list of DS names, or a prefix, followed by a star. In case of a list, Operation tries to use matching inputs in the specified order. In case of star syntax, order doesn't matter. Some Operations may require an exact number of positional inputs, while some will use all positional inputs to create an equal number of positional outputs. Please refer to Operation documentation for its requirements.</p>
<div class="hor-scroll"><img src="./spec/from_positional.svg" alt="from_positional"></div>
<p>Named INPUTs have internal aliases, specific to Pluggables. In that case, each DS has an explicit role for the calling Operation. Some Operations may have listed some named inputs optional, and for the exact meaning of omitted input please see their respective docs.</p>
<div class="hor-scroll"><img src="./spec/from_named.svg" alt="from_named"></div>
<p>Note that any referenced DS in the INOUT clause may have it own PARTITION specifier, if needed. In case of star-syntax all prefixed DSs must have referenced parts.</p>
<p>Quite unlike SELECT, an Operation may produce a number of resulting DSs. There are 3 distinct varieties of them. <b>Filtered</b> outputs have records internally unchanged from input, but selected according to some set of rules. <b>Augmented</b> outputs extend of otherwise change internal structure of records coming from inputs. Finally, there may be outputs consisting of records, <b>generated</b> from input anew. Please refer to Operation docs for each case.</p>
<p>Positional OUTPUT has meaning similar to positional INPUT. Specified star name is used for setting resulting DSs prefix (with suffixes coming from INPUT names), or a literal list of names is used, if they are comma-separated.</p>
<div class="hor-scroll"><img src="./spec/into_positional.svg" alt="into_posotional"></div>
<p>Named OUTPUTs are explicitly different, and for each of Operation OUTPUT alias, resulting DS generally is of a specified structure. Some operations may have optional named OUTPUTs.</p>
<div class="hor-scroll"><img src="./spec/into_named.svg" alt="into_named"></div>
<p>An Operation may have positional INPUTs and named OUTPUTs, or vice versa.</p>

<h3 id="ANALYZE">ANALYZE Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Performs calculation of basic statistics about the specified DS (or multiple DSs, found by prefix in the star syntax).</p>
<div class="hor-scroll"><img src="./spec/analyze_stmt.svg" alt="analyze_stmt"></div>
<p>This statement uses results of KEY expression evaluated for each DS Record as 'counting values' for DS statistics, like in TRANSFORM statement. If KEY clause is omitted, Record's own Key is used automatically.</p>
<p>After the counting value is decided, all records in the DS are iterated over to calculate the following indicators:</p>
<div class="hor-scroll"><table>
	<thead><tr><th>Statistical indicator</th><th>Meaning</th></tr></thead>
	<tbody>
		<tr><td>_name</td><td>DS name</td></tr>
		<tr><td>_type</td><td>DS Record type</td></tr>
		<tr><td>_parts</td><td>Number of DS partitions</td></tr>
		<tr><td>_counter</td><td>KEY expression</td></tr>
		<tr><td>_total</td><td>Count of records in the DS, like COUNT * in SQL</td></tr>
		<tr><td>_unique</td><td>Number of unique counting values</td></tr>
		<tr><td>_average</td><td>Average number of records per each of unique counting value</td></tr>
		<tr><td>_median</td><td>Median number of records per each of unique counting value</td></tr>
	</tbody>
</table></div>
<p>They are appended to a special Columnar DS named "_metrics" as a new record. Its records keys are always names of analyzed DSs.</p>
<p>Because each DS may be altered multiple times in their life cycle, and because ANALYZE may be called another time for same DS (i.e. with different KEY expression), each successive invocation of ANALYZE for same DS adds a new record to "_metrics" DS instead of replacing it, keeping history of all ANALYZE calls.</p>
<h4 id="PARTITION">Per-partition <a class="toc" href="#TOC">↑</a></h4>
<p>If PARTITION clause is specified, an additional round of statistics calculation is performed for each partition of the analyzed DS. In that case, an additional special Columnar DS is created for each analyzed DS, named "_metrics_&lt;DS name&gt;". There are as many records in that DS as many partitions it has, and their fields contain the following indicators:</p>
<div class="hor-scroll"><table>
	<thead><tr><th>Statistical indicator</th><th>Meaning</th></tr></thead>
	<tbody>
	<tr><td>_part</td><td>Partition number, starting with 0</td></tr>
	<tr><td>_counter</td><td>KEY expression</td></tr>
	<tr><td>_total</td><td>Count of records in the partition</td></tr>
	<tr><td>_unique</td><td>Number of unique counting values per partition</td></tr>
	<tr><td>_average</td><td>Average number of records per each of unique counting value per partition</td></tr>
	<tr><td>_median</td><td>Median number of records per each of unique counting value per partition</td></tr>
	</tbody>
</table></div>
<p>Its records keys are always partition numbers of analyzed DSs. If some partition is emtpy, its indicators are amounted to zero.</p>
<p>Each subsequent ANALYZE PARTITION replaces per-partition statistics DS "_metrics_&lt;DS name&gt;", and if multiple results are required (e.g. with different KEY expressions), make sure to copy it under different names.</p>

<h2 id="Control">Control Flow Statements <a class="toc" href="#TOC">↑</a></h2>
<p>Control Flow Statements are compound, having nested Statements inside their clauses that execute under different conditions such as branching.</p>

<h3 id="LET">LET Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Defines (or undefines) a new script Variable in the current execution context.</p>
<div class="hor-scroll"><img src="./spec/let_stmt.svg" alt="let_stmt"></div>
<p>Simple expression of a Variable is same as of a Parameter expression (that means Name Array definitions are allowed). If expression result is NULL, Variable is removed from the context.</p>
<p>Arrays of values derived from DS Records may be returned as results from the limited SELECT query:</p>
<div class="hor-scroll"><img src="./spec/sub_query.svg" alt="sub_query"></div>
<p>There are a few differences from a regular SELECT query. First, only one DS must be queried (no JOINs nor UNIONs are allowed). Second, only one expression in the what-to-select list is allowed. Query constraints do work as expected, and PARTITION specifier is supported as well.</p>

<h3 id="IF">IF Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Performs control flow branching. Evaluates a Boolean expression, and executes statements nested in THEN clause for TRUE. Otherwise, executes statements in ELSE clause, if it is present, or just does nothing.</p>
<div class="hor-scroll"><img src="./spec/if_stmt.svg" alt="if_stmt"></div>
<p>Nested statements in either branches can be any number of TDL4 statements (even none).</p>

<h3 id="LOOP">LOOP Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Executes statements nested in BEGIN clause as many times as number values in the array, each time setting loop Variable to next value. If expression evaluates to NULL or array is empty, and ELSE clause is present, its nested statements will be executed once instead.</p>
<div class="hor-scroll"><img src="./spec/loop_stmt.svg" alt="loop_stmt"></div>
<p>If there was an existing Variable with same name as loop Variable in the outer context, it will be restored to its previous value, because LOOP creates a new nested context.</p>

<h3 id="RAISE">RAISE Statement <a class="toc" href="#TOC">↑</a></h3>
<p>This statement can be used to log arbitrary messages in standard output or error streams, as well as to interrupt script execution with error message.</p>
<div class="hor-scroll"><img src="./spec/raise_stmt.svg" alt="raise_stmt"></div>
<p>Supported log levels:</p>
<div class="hor-scroll"><table>
	<thead><tr><th>Level</th><th>Behavior</th></tr></thead>
	<tbody>
	<tr><td>DEBUG, INFO, LOG, NOTICE</td><td>Log message to stdout</td></tr>
	<tr><td>WARN, WARNING</td><td>Log message to stderr</td></tr>
	<tr><td>ERROR, EXCEPTION</td><td>Halt execution and throw exception with message as a reason</td></tr>
	</tbody>
</table></div>
<p>If log level is omitted, it is treated by default as ERROR.</p>

<h3 id="CREATEPROC">CREATE PROCEDURE Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Creates a sequence of statements in the current global execution context, that can be CALLed as a whole with its own context of Variables.</p>
<div class="hor-scroll"><img src="./spec/create_proc.svg" alt="create_proc"></div>
<p>Procedures exist in the same namespace as Operations, and they can't override existing Pluggables. But they can be replaced further down in the script code. For example, if your library script defines some Procedures, you may redefine some in your script by using OR REPLACE clause.</p>
<p>Each @-Parameter becomes a $-Variable inside BEGIN clause with the value assigned at the CALL context. Because Parameters become Variables, they are always named, never positional.</p>
<p>Parameters can be optional, in that case they should have default value set by an expression (evaluated in the current context, not in the CALL context). If defined without default value (just as a @Name), Parameters become mandatory and must always have a CALL value.</p>
<div class="hor-scroll"><img src="./spec/proc_param.svg" alt="proc_param"></div>

<h3 id="DROPPROC">DROP PROCEDURE Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Use this statement to remove one or many PROCEDUREs from the current global execution context.</p>
<div class="hor-scroll"><img src="./spec/drop_proc.svg" alt="drop_proc"></div>

<h3 id="CREATEFUNC">CREATE FUNCTION Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Language-level Functions provide a convenient way to call same expression many times but with different values passed as Variables.</p>
<div class="hor-scroll"><img src="./spec/create_func.svg" alt="create_func"></div>
<p>They must always return some value. In the simplest form, function body is just a single "RETURN &lt;expression&gt;" statement.</p>
<div class="hor-scroll"><img src="./spec/return_func.svg" alt="return_func"></div>
<p>In the more complex case they are similar to Procedures in the sense they also are sequences of statements executed in their own context, but these statements are limited to LET, IF, LOOP, RAISE, and RETURN. There will be an error if Function execution path doesn't end with RETURN.</p>
<div class="hor-scroll"><img src="./spec/func_stmt.svg" alt="func_stmt"></div>
<p>Compound Function Statements are allowed in limited form, except RAISE, which doesn't differ.</p>
<div class="hor-scroll"><img src="./spec/let_func.svg" alt="let_func"></div>
<p>LET can't have subqueries.</p>
<div class="hor-scroll"><img src="./spec/if_func.svg" alt="if_func"></div>
<p>IF branches are limited to other function statements.</p>
<div class="hor-scroll"><img src="./spec/loop_func.svg" alt="loop_func"></div>
<p>Same applies to LOOP.</p>
<p>Language-level Functions exist in the same namespace as Expression Functions provided by Pluggable modules, and they can't override them. But they can be replaced further down in the script code. For example, if your library script defines some Functions, you may redefine some in your script by using OR REPLACE clause.</p>
<p>Functions that have a RECORD specifier become Record-level, must always be called in Record-level contexts, and can call other Record-level Functions. They receive Record Key and Object as implicit arguments.</p>
<p>Each @-Parameter becomes a $-Variable inside BEGIN clause with the value assigned at the CALL context. In the calling site Parameters are always positional, never named.</p>
<p>Parameters can be optional, in that case they should have default value set by an expression (evaluated in the current context, not in the call context) which is used if NULL is passed in the calling site. If defined without default value (just as a @Name), Parameters become mandatory and must always have a calling site value.</p>

<h3 id="DROPFUNC">DROP FUNCTION Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Use this statement to remove one or many FUNCTIONs from the current global execution context.</p>
<div class="hor-scroll"><img src="./spec/drop_func.svg" alt="drop_func"></div>

<h2 id="Settings">Settings Statements <a class="toc" href="#TOC">↑</a></h2>

<h3 id="OPTIONS">OPTIONS Statement <a class="toc" href="#TOC">↑</a></h3>
<p>Sets internal Data Cooker parameters to specified values.</p>
<div class="hor-scroll"><img src="./spec/options_stmt.svg" alt="options_stmt"></div>
<p>Unlike all other statements, Data Cooker pulls all OPTIONS to topmost execution context and executes them once, before evaluating all other script contents. They are completely ignored thereafter, in the normal script execution flow.</p>
<p>Parameters, that may be set by OPTIONS, is dependent on Data Cooker distribution and version, so please see a dedicated doc in the distribution for exact definitions.</p>

</body></html>